# Тестовое задание для Lesta Games

## Задание №1

<details>
  <summary>Условие</summary>
  На языке Python написать алгоритм (функцию) определения четности целого числа, который будет аналогичен нижеприведенному по функциональности, но отличен по своей сути. Объяснить плюсы и минусы обеих реализаций. 
  
  Пример: 
  
  def isEven(value):
  
        return value % 2 == 0
</details>

В качестве альтернативного подхода мы можем использовать битовые операторы: они позволят проверить, какой бит на конце у числа:
если 0 -> чётное, если 1 -> нечетное.
В данной реализации используем оператор &.
Функция вернёт True, если число чётное и False, если нечётное.

Плюсы подхода:
- скорость, битовые операции будут выполняться быстрее, чем классическое деление
Минусы:
- для отрицательных чисел не будет работать в случае применения метода вычисления обратный код (one's complement)
- метод взятия остатка от деления на 2 (%) более понятен на начальном уровне

[Код](https://github.com/IgorKalchenko/lesta_games_test_tasks/blob/main/task_1_lesta.py)

## Задание №2

<details>
  <summary>Условие</summary>
  На языке Python написать минимум 2 класса, реализовывающих циклический буфер FIFO. Объяснить плюсы и минусы каждой реализации.
  
  Оценивается:
  
  - Полнота и качество реализации
  - Оформление кода
  - Наличие сравнения и пояснения по быстродействию
</details>

Первую реализацию очереди выполним с помощью кольцевого буфера на встроенном типе list.
Вторую реализацию очереди выполним аналогично первой, однако заменим list на структуру array, реализованную в модуле numpy.
Третью реализацию выполним с помощью связанного списка.

С точки зрения быстродействия 
Данная реализация имеет недостаток: ограничение на максимальный размер
Все три реализации будут схожи по быстродействию, так как все они реализуют одну структуру данных сходным образом. У циклического буфера FIFO во всех трёх реализациях скорость вставки и удаления элемента будет константной O(1). Ко всем реализациям будет относиться недостаток ограниченности очереди изначально заданным числом элементов (побочный эффект цикличной реализации FIFO). Однако можно усмотреть и некоторые потенциальные различия: 
-	В реализации через связанные списки дополнительная память будет использоваться на хранение указателя на следующий элемент. Очереди на list и array не будут иметь такого недостатка.
-	Очередь на array оказалась медленнее всех при замерах времени, требуемого на добавление и удаление 1 000 000 элементов. В данной реализации не задействуются её преимущества по быстродействию. Однако также сохраняются недостатки, связанные с необходимостью сохранять 1 тип добавляемых объектов.
-	Очередь на динамически расширяемом массиве (list) может работать чуть медленнее очереди на array, так как за счёт расширения массива добавление элементов при инициализации может иногда работать за O(N).

[Код](https://github.com/IgorKalchenko/lesta_games_test_tasks/blob/main/task_2_lesta.py)


## Задание №3

<details>
  <summary>Условие</summary>
  На языке Python предложить алгоритм, который быстрее всего (по процессорным тикам) отсортирует данный ей массив чисел. Массив может быть любого размера со случайным порядком чисел (в том числе и отсортированным). Объяснить, почему вы считаете, что функция соответствует заданным критериям.
</details>

Существует довольно много различных алгоритмов сортировок, среди которых довольно сложно выбрать лучшую. Однако для целей данной задачи можно привести реализацию сортировки Timsort, которая на данный момент является сортировкой по умолчанию в Python и ряде других языков. Timsort сочетает в себе сильные стороны 2-х других алгоритмов: сортировки слиянием и сортировки вставками. Это один из немногих алгоритмов, который в лучшем случае работает за O(N), при этом сохраняя сложность O(N*log(N)) по быстродействию в худшем случае. Алгоритм разрабатывался с поправкой на реальные данные, в которых часто встречаются последовательно возрастающие или убывающие значения, которые Timsort довольно эффективно обрабатывает.

[Код]( https://github.com/IgorKalchenko/lesta_games_test_tasks/blob/main/task_3_lesta.py)
